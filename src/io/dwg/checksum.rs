//! Checksum calculations for DWG file format.
//!
//! Mirrors ACadSharp's `DwgCheckSumCalculator`.
//!
//! Provides:
//! - Adler-32 variant checksum (used for AC18+ data section verification)
//! - Magic sequence generation (LCG-based byte sequence)
//! - Compression padding calculation

use once_cell::sync::Lazy;

/// Pre-computed magic sequence (256 bytes) generated by the LCG.
///
/// Used by the encryption/decryption routines. Generated once at startup
/// using the formula:
/// ```text
/// seed = seed * 0x343FD + 0x269EC3
/// byte = (seed >> 0x10) as u8
/// ```
/// Starting with seed = 1.
pub static MAGIC_SEQUENCE: Lazy<[u8; 256]> = Lazy::new(|| {
    let mut result = [0u8; 256];
    let mut rand_seed: i32 = 1;
    for i in 0..256 {
        rand_seed = rand_seed.wrapping_mul(0x343FD).wrapping_add(0x269EC3);
        result[i] = (rand_seed >> 0x10) as u8;
    }
    result
});

/// Calculate the number of padding bytes needed for compression alignment.
///
/// Returns the number of bytes needed to align `length` to a 32-byte boundary.
/// Formula: `0x1F - (length + 0x20 - 1) % 0x20`
///
/// Equivalent to ACadSharp `DwgCheckSumCalculator.CompressionCalculator`.
pub fn compression_padding(length: usize) -> usize {
    0x1F - (length + 0x20 - 1) % 0x20
}

/// Compute the Adler-32 variant checksum used by AC18+ DWG files.
///
/// This is not a standard Adler-32 â€” it uses modulus `0xFFF1` and processes
/// data in chunks of `0x15B0` bytes (5552), which is the same as standard
/// Adler-32's NMAX value.
///
/// The seed encodes `sum2` in the high 16 bits and `sum1` in the low 16 bits.
///
/// Equivalent to ACadSharp `DwgCheckSumCalculator.Calculate`.
pub fn adler32(seed: u32, buffer: &[u8], offset: usize, size: usize) -> u32 {
    let mut sum1 = seed & 0xFFFF;
    let mut sum2 = seed >> 16;
    let mut index = offset;
    let mut remaining = size;

    while remaining != 0 {
        let chunk_size = std::cmp::min(0x15B0, remaining);
        remaining -= chunk_size;

        for _ in 0..chunk_size {
            sum1 += buffer[index] as u32;
            sum2 += sum1;
            index += 1;
        }

        sum1 %= 0xFFF1;
        sum2 %= 0xFFF1;
    }

    (sum2 << 0x10) | (sum1 & 0xFFFF)
}

/// Generate a 256-byte magic sequence using the LCG algorithm.
///
/// Uses the formula:
/// ```text
/// seed = seed * 0x343FD + 0x269EC3
/// byte = (seed >> 0x10) as u8
/// ```
/// This is the same LCG used for encryption/decryption in the CRC-32
/// stream handler.
///
/// Equivalent to the static initializer in ACadSharp `DwgCheckSumCalculator`.
pub fn generate_magic_sequence(initial_seed: i32) -> [u8; 256] {
    let mut result = [0u8; 256];
    let mut rand_seed = initial_seed;
    for i in 0..256 {
        rand_seed = rand_seed.wrapping_mul(0x343FD).wrapping_add(0x269EC3);
        result[i] = (rand_seed >> 0x10) as u8;
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_magic_sequence_first_bytes() {
        // Verify against the known LCG output with seed=1
        let seq = &*MAGIC_SEQUENCE;
        // seed=1: 1*0x343FD+0x269EC3 = 0x29D2C0 => (0x29D2C0 >> 0x10) = 0x29 = 41
        let mut s: i32 = 1;
        s = s.wrapping_mul(0x343FD).wrapping_add(0x269EC3);
        assert_eq!(seq[0], (s >> 0x10) as u8);
        s = s.wrapping_mul(0x343FD).wrapping_add(0x269EC3);
        assert_eq!(seq[1], (s >> 0x10) as u8);
    }

    #[test]
    fn test_generate_magic_sequence_matches_static() {
        let dynamic = generate_magic_sequence(1);
        assert_eq!(&dynamic[..], &MAGIC_SEQUENCE[..]);
    }

    #[test]
    fn test_compression_padding() {
        // length=0: 0x1F - (0 + 0x1F) % 0x20 = 0x1F - 0x1F = 0
        assert_eq!(compression_padding(0), 0);
        // (1 + 0x20 - 1) % 0x20 = 0x20 % 0x20 = 0 => 0x1F - 0 = 0x1F
        assert_eq!(compression_padding(1), 0x1F);
        // (32 + 0x20 - 1) % 0x20 = (32 + 31) % 32 = 63 % 32 = 31 => 0x1F - 31 = 0
        assert_eq!(compression_padding(32), 0);
        // (33 + 31) % 32 = 64 % 32 = 0 => 0x1F - 0 = 31
        assert_eq!(compression_padding(33), 0x1F);
    }

    #[test]
    fn test_adler32_empty() {
        assert_eq!(adler32(1, &[], 0, 0), 1);
    }

    #[test]
    fn test_adler32_basic() {
        let data = [0x01, 0x02, 0x03, 0x04];
        let result = adler32(1, &data, 0, 4);
        // sum1 = 1 + 1 + 2 + 3 + 4 = 11
        // sum2 = 0 + (1+1) + (1+1+2) + (1+1+2+3) + (1+1+2+3+4) = 2+4+7+11 = 24
        // Wait: seed = 1, so sum1 starts at 1, sum2 starts at 0
        // After byte 1: sum1 = 1+1=2, sum2 = 0+2=2
        // After byte 2: sum1 = 2+2=4, sum2 = 2+4=6
        // After byte 3: sum1 = 4+3=7, sum2 = 6+7=13
        // After byte 4: sum1 = 7+4=11, sum2 = 13+11=24
        assert_eq!(result, (24 << 16) | 11);
    }

    #[test]
    fn test_adler32_with_offset() {
        let data = [0x00, 0x01, 0x02, 0x03, 0x04, 0x00];
        let result1 = adler32(1, &data, 1, 4);
        let data2 = [0x01, 0x02, 0x03, 0x04];
        let result2 = adler32(1, &data2, 0, 4);
        assert_eq!(result1, result2);
    }
}
